{"_id":"GSRm3HoKLebK8FgD","name":"CreateMacroTiles","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.CIKafmQfYil9KBYr"}},"scope":"global","command":"//Select the tiles you want to hide or reveal by stepping on to the \"Tiles Visibility Toggle\" Token/Plate and execute this macro.\n//It will create a macro called \"Tiles Visibility Toggle\". Afterwards, execute the \"PopulateTriggerJournalEntry\" macro (Everytime you create a macro, the id changes even if the name is the same but careful not to have two macros with the same name !\n\n//Let's create an array of the controlled (selected) tiles on the canvas and store their id into another array\nvar myTilesArray = Array.from(canvas.tiles.controlled);\nvar myTilesIDArray = new Array();\n\nconst wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function TilesToggle() {\n    \n   \n    for (var i = 0; i < myTilesArray.length; i++) {\n    let tileID = myTilesArray[i].id;\n    myTilesIDArray[i] = tileID;\n    }    \nconst myTilesIDArrayStr = JSON.stringify(myTilesIDArray);\n   \n    await wait (75);\n//everything in between backticks stored into the variable \"command\" will be the code for the \"Tiles Visibility Toggle\" macro !\n    var command = `//This macro will toglle the visibility of a tile from its ID \n    const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n    async function TilesToggle() {\n        \n        var myTilesIDArray = ${myTilesIDArrayStr};\n    \n    \n       for (var i = 0; i < myTilesIDArray.length; i++) {\n        \n        let tileID = myTilesIDArray[i];\n        const tile = canvas.tiles.get(tileID);\n        if(tile) tile.update({ hidden : !tile.data.hidden });\n        await wait (250);\n    \n        }\n        await wait (75);\n    }\n    \n        TilesToggle();`;\n    \n    var macro = await Macro.create({\n        name: \"Tiles Visibility Toggle\",\n        type: \"script\",\n        img: \"icons/svg/eye.svg\",\n        command: `${command}`,\n        canRunAsGM: true\n    }, {displaySheet: false});\n \n\n}\nTilesToggle();","author":"I78VA6a780HpLHg7","img":"icons/svg/book.svg","actorIds":[]}
{"_id":"UnO5Vp5HyNfc0wqf","name":"CreateMacroDoors","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.jrPe2n3pRmhxgZNu"}},"scope":"global","command":"//This macro will create another macro, storing the Ids of the tiles selected in an array.\nvar myDoorsArray = Array.from(canvas.walls.controlled);\nvar myDoorsIDArray = new Array();\n\nconst wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function TilesToggle() {\n    \n    \n    for (var i = 0; i < myDoorsArray.length; i++) {\n    let doorID = myDoorsArray[i].id;\n    myDoorsIDArray[i] = doorID;\n    }\n    const myDoorsIDArrayStr = JSON.stringify(myDoorsIDArray);\n   \n    await wait (75);\n    var command = `//This macro will toglle the state of doors from their ID\n    const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function DoorsToggle() {\nvar myDoorsIDArray = ${myDoorsIDArrayStr};\n\nfor (var i = 0; i < myDoorsIDArray.length; i++) {\n\nlet doorID = myDoorsIDArray[i];\nconst door = canvas.walls.get(doorID);\ndoor.update({ds: door.data.ds ? 0 : 1});\nawait wait (250);\n\n}\nawait wait (75);\n}\n\nDoorsToggle();`;\n\n    \n    var macro = await Macro.create({\n        name: \"Doors State Toggle\",\n        type: \"script\",\n        img: \"icons/svg/door-exit.svg\",\n        command: `${command}`,\n        canRunAsGM: true\n    }, {displaySheet: false});\n \n\n}\nTilesToggle();\n\nconsole.log(myDoorsIDArray);","author":"I78VA6a780HpLHg7","img":"icons/svg/book.svg","actorIds":[]}
{"name":"PressurePlate","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.qtU7qZFGkm7cpeSS"}},"scope":"global","command":"//These lines starting with a \"//\" or surrounded by \"/*\" and \"*/\" are comments that are ignored when executing the macro.\n//This macro checks the content of two Journal Entries. If they're the same, the players have solved it \n//and the doors will open. \n//I've added a Timer that will reset the chamber after a few seconds !\n\n//We define here the name of the two Journal Entries we're going to check against each other\nvar journalGMName = game.journal.getName(\"GMSolution\");\nvar journalPName = game.journal.getName(\"PlayerEntry\");\n\n//Let's define the Pressure Plate as well so we can play the animation from it.\nconst plateName = `PressurePlate`;\nvar mainTarget = canvas.tokens.placeables.find(i=> i.name === plateName);\n\n//This is where I define the path to each animations. file is the folder and each animation is stored into its own variable \nlet file = \"modules/jb2a_patreon/Library/Generic/Music_Notation/\";\n\nlet aa = `${file}BassClef_01_Regular_Blue_200x200.webm`;\nlet ab = `${file}BassClef_01_Regular_Green_200x200.webm`;\nlet ac = `${file}BassClef_01_Regular_Orange_200x200.webm`;\nlet ad = `${file}BassClef_01_Regular_Purple_200x200.webm`;\nlet ae = `${file}TrebleClef_01_Regular_Blue_200x200.webm`;\nlet af = `${file}TrebleClef_01_Regular_Green_200x200.webm`;\nlet ag = `${file}TrebleClef_01_Regular_Orange_200x200.webm`;\nlet ah = `${file}TrebleClef_01_Regular_Purple_200x200.webm`;\n\nlet ba = `${file}Flat_01_Regular_Blue_200x200.webm`;\nlet bb = `${file}Flat_01_Regular_Green_200x200.webm`;\nlet bc = `${file}Flat_01_Regular_Orange_200x200.webm`;\nlet bd = `${file}Flat_01_Regular_Purple_200x200.webm`;\nlet be = `${file}Sharp_01_Regular_Blue_200x200.webm`;\nlet bf = `${file}Sharp_01_Regular_Green_200x200.webm`;\nlet bg = `${file}Sharp_01_Regular_Orange_200x200.webm`;\nlet bh = `${file}Sharp_01_Regular_Purple_200x200.webm`;\n\nlet ca = `${file}BeamedQuavers_01_Regular_Blue_200x200.webm`;\nlet cb = `${file}BeamedQuavers_01_Regular_Green_200x200.webm`;\nlet cc = `${file}BeamedQuavers_01_Regular_Orange_200x200.webm`;\nlet cd = `${file}BeamedQuavers_01_Regular_Purple_200x200.webm`;\nlet ce = `${file}Crotchet_01_Regular_Blue_200x200.webm`;\nlet cf = `${file}Crotchet_01_Regular_Green_200x200.webm`;\nlet cg = `${file}Crotchet_01_Regular_Orange_200x200.webm`;\nlet ch = `${file}Crotchet_01_Regular_Purple_200x200.webm`;\nlet ci = `${file}Quaver_01_Regular_Blue_200x200.webm`;\nlet cj = `${file}Quaver_01_Regular_Green_200x200.webm`;\nlet ck = `${file}Quaver_01_Regular_Orange_200x200.webm`;\nlet cl = `${file}Quaver_01_Regular_Purple_200x200.webm`;\n\n\n//Pull a random colour from the BassClef or TrebleClef animations\nfunction random_itemA(itemsA)\n{\nreturn itemsA[Math.floor(Math.random()*itemsA.length)];\n}\n\nvar itemsA = [aa, ab, ac, ad, ae, af, ag, ah];\n\n//Sharp or Flat\nfunction random_itemB(itemsB)\n{\nreturn itemsB[Math.floor(Math.random()*itemsB.length)];\n}\n\nvar itemsB = [ba, bb ,bc, bd, be, bf, bg, bh];\n\n//Notes\nfunction random_itemC(itemsC)\n{\nreturn itemsC[Math.floor(Math.random()*itemsC.length)];\n}\n\nvar itemsC = [ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck, cl];\n\n\n\n\n//This returns an error to the user if FXMaster is not installed\nif (!canvas.fxmaster) ui.notifications.error(\"This macro depends on the FXMaster module. Make sure it is installed and enabled\");\n\nconst wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n//This whole \"Pressure Plate\" function will be executed at the end. We use an if statement to check if the two journal entries are exactly the same.\n//If they are, we open the three doors, reveal the portal. They've done it !\n//if not (what is in the else statement) We reset the puzzle, cast the new four animations pattern, paste it in the GM Journal Entry, reset the Player's Journal Entry,\n//and close the doors and hide the tiles and we send a message to the GM with links to the Journal Entries !\nasync function PressurePlate() {\n\n//The console.log allows to output some text, for example here, to check if the function has been executed.\n//console.log(\"Inside the PressurePlate Function\");\n\n//The if statement below means this : if journal entries are the same, Puzzle is resolved, the doors open and the tile (portal) is revealed \nif (journalGMName.data.content === journalPName.data.content){\n  \n  //Let's call the macro that toggle the doors open (if they're already open, they will close instead ! )\n  const DoorsStateToggle = game.macros.getName(\"Doors State Toggle\");\n  DoorsStateToggle.execute();\n  //We set an await, a delay in milliseconds, 1000 will roughly be equivalent to 1 second.\n  \n    //This is the countdown timer section\n  journalPName.update({content: `<h1>You have 5 seconds to exit the chamber</h1>`});\n  //We set an await, a delay in milliseconds, 1000 will roughly be equivalent to 1 second.\n  await wait (2000); \n  journalPName.update({content: `<h1>4</h1>`});\n  await wait (1000); \n  journalPName.update({content: `<h1>3</h1>`});\n  await wait (1000); \n  journalPName.update({content: `<h1>2</h1>`});\n  await wait (1000); \n  console.log(\"2\");\n  await wait (1000); \n  journalPName.update({content: `<h1>1</h1>`});\n  await wait (1000); \n  journalPName.update({content: `<h1>0</h1>`});\n  await wait (1000); \n  journalPName.update({content: ` `});\n  //Here we close the doors from the macro \"Door State Toggle\"\n  DoorsStateToggle.execute();\n  \n  //Here I'll trigger another macro that will only draw a new random pattern in the GM's Journal Entry\n  const pattern = game.macros.getName(\"Create New Pattern\");\n  await wait (100);\n  pattern.execute();\n  \n\n\n}\n// else (if 2 journal Entries are different, draw a new pattern as four animations, four images in the GM journal entry and reset the player's journal entry\nelse{\n  //We're going to prepare everything Foudnry will have to do when we call upon this \"CastA\"function\n  //We're picking at random from the items A which are the Treble Clefs and Bass Clefs. We'll do the same \n  //for the next function \"CastB\" but with sharps and flats, then all the notes will be picked at random \n  //in the  \"CastC\" function (that we'll call twice, we'll see that a bit later on)\nasync function CastA() {\n\n\nlet spellAnim = \n                    {\n                     file: random_itemA(itemsA),\n                      position: mainTarget.center,\n                      anchor: {\n                       x: 0.5,\n                       y: 1\n                      },\n                      angle: 0,\n                      scale: {\n                       x: 1,\n                       y: 1\n                      }\n                    }; \ncanvas.fxmaster.playVideo(spellAnim);\ngame.socket.emit('module.fxmaster', spellAnim);\nawait wait (500);\n\n//Here, I'm manipulating html text to truncate the path and replace it with the one for the webp thumbnail image\n//that I'll use to paste in the journal entry\nconst path = spellAnim.file.substr(52);\nconst thumb = path.slice(0, -12) + \"Thumb.webp\";\nconst webP = `${file}` + `${thumb}`;\nconst imgWidth = \"100\";\n\n//define \"content\" that will be pasted into the GM's Journal Entry\nconst content = ` <img src = \"${webP}\" width = \"${imgWidth}\" /> `;\n\n//Straight up replace anything that was already in the GM's Journal Entry by the first picture (defined as a variable above)\njournalGMName.update({content: content});\n\n\n\n}\nasync function CastB() {\n \n  \n  let spellAnim = \n                      {\n                       file: random_itemB(itemsB),\n                        position: mainTarget.center,\n                        anchor: {\n                         x: 0.5,\n                         y: 1\n                        },\n                        angle: 0,\n                        scale: {\n                         x: 1,\n                         y: 1\n                        }\n                      }; \n  canvas.fxmaster.playVideo(spellAnim);\n  game.socket.emit('module.fxmaster', spellAnim);\n  await wait (500);\n  const source = canvas.tokens.controlled[0];\n  const path = spellAnim.file.substr(52);\n  const thumb = path.slice(0, -12) + \"Thumb.webp\";\n  const webP = `${file}` + `${thumb}`;\n  const imgWidth = \"100\";\n\n\n  const content = `<img src = \"${webP}\" width = \"${imgWidth}\" /> `;\n  \n  journalGMName.update({content: journalGMName.data.content + content});\n\n  \n  }\n  async function CastC() {\n    \n    \n    let spellAnim = \n                        {\n                         file: random_itemC(itemsC),\n                          position: mainTarget.center,\n                          anchor: {\n                           x: 0.5,\n                           y: 1\n                          },\n                          angle: 0,\n                          scale: {\n                           x: 1,\n                           y: 1\n                          }\n                        }; \n    canvas.fxmaster.playVideo(spellAnim);\n    game.socket.emit('module.fxmaster', spellAnim);\n    await wait (500);\n    const source = canvas.tokens.controlled[0];\n    const path = spellAnim.file.substr(52);\n    const thumb = path.slice(0, -12) + \"Thumb.webp\";\n    const webP = `${file}` + `${thumb}`;\n    const imgWidth = \"100\";\n    \n\n    const content = `<img src = \"${webP}\" width = \"${imgWidth}\" /> `;\n  journalGMName.update({content: journalGMName.data.content + content});    \n    \n    }\n    \n//ChatMessage to GM with the two Journal Entries linked remove the \"/*\" and \"*/\" to test it. It can clutter if there are two many PressurePlate activations !\n/*\nlet chatData = {\n   \n  content: `Someone changed the pattern ! <br> @JournalEntry[${journalGMName.data.name}] <br> @JournalEntry[${journalPName.data.name}]`,\n  whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData, {});\n*/\n\n\n //Reset the Player's Journal Entry (with a single space to avoid a null)\n const content = ` `;\n journalPName.update({content: content});\n\n //Now all the functions are ready to be executed. \"CastA\" once, \"CastB\" once and \"CastC\" twice, close the all thing \n //and call the overall function called \"PressurePlate\"\nCastA ();\nawait wait (750);\nCastB();\nawait wait (750);\nCastC ();\nawait wait (750);\nCastC ();\nawait wait (750);\n  }\n}\nPressurePlate();","author":"I78VA6a780HpLHg7","img":"icons/environment/traps/pressure-plate.webp","actorIds":[],"_id":"cW6UJyrlfKQRxruc"}
{"name":"Create New Pattern","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.jlT6FWIvykLrZbdU"}},"scope":"global","command":"//plateName is the name of the actor(pressure plate idea) that the player is going to step upon.\nconst plateName = `PressurePlate`;\nvar mainTarget = canvas.tokens.placeables.find(i=> i.name === plateName);\nvar journalGMName = game.journal.getName(\"GMSolution\");\n\n//This is where I define the path to each animations. file is the folder and each animation is stored into its own variable \nlet file = \"modules/jb2a_patreon/Library/Generic/Music_Notation/\";\n\nlet aa = `${file}BassClef_01_Regular_Blue_200x200.webm`;\nlet ab = `${file}BassClef_01_Regular_Green_200x200.webm`;\nlet ac = `${file}BassClef_01_Regular_Orange_200x200.webm`;\nlet ad = `${file}BassClef_01_Regular_Purple_200x200.webm`;\nlet ae = `${file}TrebleClef_01_Regular_Blue_200x200.webm`;\nlet af = `${file}TrebleClef_01_Regular_Green_200x200.webm`;\nlet ag = `${file}TrebleClef_01_Regular_Orange_200x200.webm`;\nlet ah = `${file}TrebleClef_01_Regular_Purple_200x200.webm`;\n\nlet ba = `${file}Flat_01_Regular_Blue_200x200.webm`;\nlet bb = `${file}Flat_01_Regular_Green_200x200.webm`;\nlet bc = `${file}Flat_01_Regular_Orange_200x200.webm`;\nlet bd = `${file}Flat_01_Regular_Purple_200x200.webm`;\nlet be = `${file}Sharp_01_Regular_Blue_200x200.webm`;\nlet bf = `${file}Sharp_01_Regular_Green_200x200.webm`;\nlet bg = `${file}Sharp_01_Regular_Orange_200x200.webm`;\nlet bh = `${file}Sharp_01_Regular_Purple_200x200.webm`;\n\nlet ca = `${file}BeamedQuavers_01_Regular_Blue_200x200.webm`;\nlet cb = `${file}BeamedQuavers_01_Regular_Green_200x200.webm`;\nlet cc = `${file}BeamedQuavers_01_Regular_Orange_200x200.webm`;\nlet cd = `${file}BeamedQuavers_01_Regular_Purple_200x200.webm`;\nlet ce = `${file}Crotchet_01_Regular_Blue_200x200.webm`;\nlet cf = `${file}Crotchet_01_Regular_Green_200x200.webm`;\nlet cg = `${file}Crotchet_01_Regular_Orange_200x200.webm`;\nlet ch = `${file}Crotchet_01_Regular_Purple_200x200.webm`;\nlet ci = `${file}Quaver_01_Regular_Blue_200x200.webm`;\nlet cj = `${file}Quaver_01_Regular_Green_200x200.webm`;\nlet ck = `${file}Quaver_01_Regular_Orange_200x200.webm`;\nlet cl = `${file}Quaver_01_Regular_Purple_200x200.webm`;\n\n\n//Pull a random colour from the BassClef or TrebleClef animations\nfunction random_itemA(itemsA)\n{\nreturn itemsA[Math.floor(Math.random()*itemsA.length)];\n}\n\nvar itemsA = [aa, ab, ac, ad, ae, af, ag, ah];\n\n//Sharp or Flat\nfunction random_itemB(itemsB)\n{\nreturn itemsB[Math.floor(Math.random()*itemsB.length)];\n}\n\nvar itemsB = [ba, bb ,bc, bd, be, bf, bg, bh];\n\n//Notes\nfunction random_itemC(itemsC)\n{\nreturn itemsC[Math.floor(Math.random()*itemsC.length)];\n}\n\nvar itemsC = [ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck, cl];\n\nconst wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function CastA() {\n    \n    \n    let spellAnim = \n                        {\n                         file: random_itemA(itemsA),\n                          position: mainTarget.center,\n                          anchor: {\n                           x: 0.5,\n                           y: 1\n                          },\n                          angle: 0,\n                          scale: {\n                           x: 1,\n                           y: 1\n                          }\n                        }; \n    canvas.fxmaster.playVideo(spellAnim);\n    game.socket.emit('module.fxmaster', spellAnim);\n    await wait (500);\n    \n    //Here, I'm manipulating html text to truncate the path and replace it with the one for the webp thumbnail image\n    //that I'll use to paste in the journal entry\n    const path = spellAnim.file.substr(52);\n    const thumb = path.slice(0, -12) + \"Thumb.webp\";\n    const webP = `${file}` + `${thumb}`;\n    const imgWidth = \"100\";\n    \n    //define \"content\" that will be pasted into the GM's Journal Entry\n    const content = ` <img src = \"${webP}\" width = \"${imgWidth}\" /> `;\n    \n    //Straight up replace anything that was already in the GM's Journal Entry by the first picture (defined as a variable above)\n    journalGMName.update({content: content});\n    \n    \n    }\n    \n    async function CastB() {\n      \n      \n      let spellAnim = \n                          {\n                           file: random_itemB(itemsB),\n                            position: mainTarget.center,\n                            anchor: {\n                             x: 0.5,\n                             y: 1\n                            },\n                            angle: 0,\n                            scale: {\n                             x: 1,\n                             y: 1\n                            }\n                          }; \n      canvas.fxmaster.playVideo(spellAnim);\n      game.socket.emit('module.fxmaster', spellAnim);\n      await wait (500);\n      var source = canvas.tokens.controlled[0];\n      var path = spellAnim.file.substr(52);\n      var thumb = path.slice(0, -12) + \"Thumb.webp\";\n      var webP = `${file}` + `${thumb}`;\n      var imgWidth = \"100\";\n    \n    \n      const content = `<img src = \"${webP}\" width = \"${imgWidth}\" /> `;\n      \n      journalGMName.update({content: journalGMName.data.content + content});\n    \n      }\n      \n      async function CastC() {\n        \n        \n        let spellAnim = \n                            {\n                             file: random_itemC(itemsC),\n                              position: mainTarget.center,\n                              anchor: {\n                               x: 0.5,\n                               y: 1\n                              },\n                              angle: 0,\n                              scale: {\n                               x: 1,\n                               y: 1\n                              }\n                            }; \n        canvas.fxmaster.playVideo(spellAnim);\n        game.socket.emit('module.fxmaster', spellAnim);\n        await wait (500);\n        var source = canvas.tokens.controlled[0];\n        var path = spellAnim.file.substr(52);\n        var thumb = path.slice(0, -12) + \"Thumb.webp\";\n        var webP = `${file}` + `${thumb}`;\n        var imgWidth = \"100\";\n        \n    \n        const content = `<img src = \"${webP}\" width = \"${imgWidth}\" /> `;\n      journalGMName.update({content: journalGMName.data.content + content});    \n        }\n        \n        //ChatMessage to GM\n    /*var source = canvas.tokens.controlled[0];\n    ChatMessage.create({\n      //Here I'm telling who has stepped onto the plate and reset the pattern\n      speaker: ChatMessage.getSpeaker(source),\n      //I'm also linking the two Journal entries into a ChatCard only visible by the GM\n      //journal01 = journalGMName.data.name;\n      //journal02 = journalPName.data.name;\n      content: `${source.data.name} changed the pattern ! <br> @JournalEntry[${journalGMName.data.name}] <br> @JournalEntry[${journalPName.data.name}]`,\n      type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n      whisper : ChatMessage.getWhisperRecipients(\"GM\")\n    });\n    */\n        \n     //Now all the functions are ready to be executed. \"CastA\" once, \"CastB\" once and \"CastC\" twice, close the all thing \n     //and call the overall function called \"PressurePlate\"\n    CastA ();\n    await wait (750);\n    CastB();\n    await wait (750);\n    CastC ();\n    await wait (750);\n    CastC ();\n    await wait (750);","author":"I78VA6a780HpLHg7","img":"icons/sundries/scrolls/scroll-writing-grey.webp","actorIds":[],"_id":"hB8gQNlHqjGGImhO"}
{"name":"PopulateTriggerJournalEntry","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.AMJfNMbtrsytAD96"}},"scope":"global","command":"let macroPP = game.macros.getName(\"PressurePlate\").id;\nlet macroTVT = game.macros.getName(\"Tiles Visibility Toggle\").id;\nlet macroBCB = game.macros.getName(\"BassClef Blue\").id;\nlet macroBCG = game.macros.getName(\"BassClef Green\").id;\nlet macroBCO = game.macros.getName(\"BassClef Orange\").id;\nlet macroBCP = game.macros.getName(\"BassClef Purple\").id;\nlet macroBQB = game.macros.getName(\"TrebleClef Blue\").id;\nlet macroBQG = game.macros.getName(\"TrebleClef Green\").id;\nlet macroBQO = game.macros.getName(\"TrebleClef Orange\").id;\nlet macroBQP = game.macros.getName(\"TrebleClef Purple\").id;\nlet macroCB = game.macros.getName(\"Flat Blue\").id;\nlet macroCG = game.macros.getName(\"Flat Green\").id;\nlet macroCO = game.macros.getName(\"Flat Orange\").id;\nlet macroCP = game.macros.getName(\"Flat Purple\").id;\nlet macroFB = game.macros.getName(\"Sharp Blue\").id;\nlet macroFG = game.macros.getName(\"Sharp Green\").id;\nlet macroFO = game.macros.getName(\"Sharp Orange\").id;\nlet macroFP = game.macros.getName(\"Sharp Purple\").id;\nlet macroQB = game.macros.getName(\"BeamedQuavers Blue\").id;\nlet macroQG = game.macros.getName(\"BeamedQuavers Green\").id;\nlet macroQO = game.macros.getName(\"BeamedQuavers Orange\").id;\nlet macroQP = game.macros.getName(\"BeamedQuavers Purple\").id;\nlet macroSB = game.macros.getName(\"Crotchet Blue\").id;\nlet macroSG = game.macros.getName(\"Crotchet Green\").id;\nlet macroSO = game.macros.getName(\"Crotchet Orange\").id;\nlet macroSP = game.macros.getName(\"Crotchet Purple\").id;\nlet macroTCB = game.macros.getName(\"Quaver Blue\").id;\nlet macroTCG = game.macros.getName(\"Quaver Green\").id;\nlet macroTCO = game.macros.getName(\"Quaver Orange\").id;\nlet macroTCP = game.macros.getName(\"Quaver Purple\").id;\n\n\n\n\nvar journalTrigger = game.journal.getName(\"Trigger\");\n\n//define the \"content\" that will be pasted into the Trigger Journal Entry\nconst content = \"@Token[PressurePlate]@Trigger[capture move]@Macro[\" + macroPP +  \"]{PressurePlate}\"+\"<br>\"+\n\"@Token[Tiles Visibility Toggle]@Trigger[capture move]@Macro[\" + macroTVT + \"]{Tiles Visibility Toggle}\"+\"<br><br>\"+\n\"@Token[BassClef Blue]@Trigger[capture move]@Macro[\" + macroBCB + \"]{BassClef Blue}\"+\"<br>\"+\n\"@Token[BassClef Green]@Trigger[capture move]@Macro[\" + macroBCG + \"]{BassClef Green}\"+\"<br>\"+\n\"@Token[BassClef Orange]@Trigger[capture move]@Macro[\" + macroBCO + \"]{BassClef Orange}\"+\"<br>\"+\n\"@Token[BassClef Purple]@Trigger[capture move]@Macro[\" + macroBCP + \"]{BassClef Purple}\"+\"<br><br>\"+\n\"@Token[TrebleClef Blue]@Trigger[capture move]@Macro[\" + macroBQB + \"]{TrebleClef Blue}\"+\"<br>\"+\n\"@Token[TrebleClef Green]@Trigger[capture move]@Macro[\" + macroBQG + \"]{TrebleClef Green}\"+\"<br>\"+\n\"@Token[TrebleClef Orange]@Trigger[capture move]@Macro[\" + macroBQO + \"]{TrebleClef Orange}\"+\"<br>\"+\n\"@Token[TrebleClef Purple]@Trigger[capture move]@Macro[\" + macroBQP + \"]{TrebleClef Purple}\"+\"<br><br>\"+\n\"@Token[Flat Blue]@Trigger[capture move]@Macro[\" + macroCB  + \"]{Flat Blue}\"+\"<br>\"+\n\"@Token[Flat Green]@Trigger[capture move]@Macro[\" + macroCG  + \"]{Flat Green}\"+\"<br>\"+\n\"@Token[Flat Orange]@Trigger[capture move]@Macro[\" + macroCO  + \"]{Flat Orange}\"+\"<br>\"+\n\"@Token[Flat Purple]@Trigger[capture move]@Macro[\" + macroCP  + \"]{Flat Purple}\"+\"<br><br>\"+\n\"@Token[Sharp Blue]@Trigger[capture move]@Macro[\" + macroFB  + \"]{Sharp Blue}\"+\"<br>\"+\n\"@Token[Sharp Green]@Trigger[capture move]@Macro[\" + macroFG  + \"]{Sharp Green}\"+\"<br>\"+\n\"@Token[Sharp Orange]@Trigger[capture move]@Macro[\" + macroFO  + \"]{Sharp Orange}\"+\"<br>\"+\n\"@Token[Sharp Purple]@Trigger[capture move]@Macro[\" + macroFP  + \"]{Sharp Purple}\"+\"<br><br>\"+\n\"@Token[Beamed Quavers Blue]@Trigger[capture move]@Macro[\" + macroQB  + \"]{BeamedQuavers Blue}\"+\"<br>\"+\n\"@Token[Beamed Quavers Green]@Trigger[capture move]@Macro[\" + macroQG  + \"]{BeamedQuavers Green}\"+\"<br>\"+\n\"@Token[Beamed Quavers Orange]@Trigger[capture move]@Macro[\" + macroQO  + \"]{BeamedQuavers Orange}\"+\"<br>\"+\n\"@Token[Beamed Quavers Purple]@Trigger[capture move]@Macro[\" + macroQP  + \"]{BeamedQuavers Purple}\"+\"<br><br>\"+\n\"@Token[Crotchet Blue]@Trigger[capture move]@Macro[\" + macroSB  + \"]{Crotchet Blue}\"+\"<br>\"+\n\"@Token[Crotchet Green]@Trigger[capture move]@Macro[\" + macroSG  + \"]{Crotchet Green}\"+\"<br>\"+\n\"@Token[Crotchet Orange]@Trigger[capture move]@Macro[\" + macroSO  + \"]{Crotchet Orange}\"+\"<br>\"+\n\"@Token[Crotchet Purple]@Trigger[capture move]@Macro[\" + macroSP  + \"]{Crotchet Purple}\"+\"<br><br>\"+\n\"@Token[Quaver Blue]@Trigger[capture move]@Macro[\" + macroTCB + \"]{Quaver Blue}\"+\"<br>\"+\n\"@Token[Quaver Green]@Trigger[capture move]@Macro[\" + macroTCG + \"]{Quaver Green}\"+\"<br>\"+\n\"@Token[Quaver Orange]@Trigger[capture move]@Macro[\" + macroTCO + \"]{Quaver Orange}\"+\"<br>\"+\n\"@Token[Quaver Purple]@Trigger[capture move]@Macro[\" + macroTCP + \"]{Quaver Purple}\"+\"<br><hr>\";\n\n//Straight up replace anything that was already in the GM's Journal Entry by the first picture (defined as a variable above)\njournalTrigger.update({content: content});","author":"I78VA6a780HpLHg7","img":"icons/svg/book.svg","actorIds":[],"_id":"v85yDeY3rbQM8Uoc"}
{"_id":"UnO5Vp5HyNfc0wqf","name":"CreateMacroDoors","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.jrPe2n3pRmhxgZNu"}},"scope":"global","command":"//This macro will create another macro, storing the Ids of the tiles selected in an array.\nvar myDoorsArray = Array.from(canvas.walls.controlled);\nvar myDoorsIDArray = new Array();\n\nconst wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function TilesToggle() {\n    \n    \n    for (var i = 0; i < myDoorsArray.length; i++) {\n    let doorID = myDoorsArray[i].id;\n    myDoorsIDArray[i] = doorID;\n    }\n    const myDoorsIDArrayStr = JSON.stringify(myDoorsIDArray);\n   \n    await wait (75);\n    var command = `//This macro will toglle the state of doors from their ID\n    const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function DoorsToggle() {\nvar myDoorsIDArray = ${myDoorsIDArrayStr};\n\nfor (var i = 0; i < myDoorsIDArray.length; i++) {\n\nlet doorID = myDoorsIDArray[i];\nconst door = canvas.walls.get(doorID);\ndoor.update({ds: door.data.ds ? 0 : 1});\nawait wait (250);\n\n}\nawait wait (75);\n}\n\nDoorsToggle();`;\n\n    \n    var macro = await Macro.create({\n        name: \"Doors State Toggle\",\n        type: \"script\",\n        img: \"icons/svg/door-exit.svg\",\n        command: `${command}`,\n        \"flags\": {\n            \"furnace\": {\n              \"runAsGM\": true\n            }}\n    }, {displaySheet: false});\n \n\n}\nTilesToggle();\n\nconsole.log(myDoorsIDArray);","author":"I78VA6a780HpLHg7","img":"icons/svg/book.svg","actorIds":[]}
{"_id":"GSRm3HoKLebK8FgD","name":"CreateMacroTiles","permission":{"default":0,"I78VA6a780HpLHg7":3},"type":"script","flags":{"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.CIKafmQfYil9KBYr"}},"scope":"global","command":"//Select the tiles you want to hide or reveal by stepping on to the \"Tiles Visibility Toggle\" Token/Plate and execute this macro.\n//It will create a macro called \"Tiles Visibility Toggle\". Afterwards, execute the \"PopulateTriggerJournalEntry\" macro (Everytime you create a macro, the id changes even if the name is the same but careful not to have two macros with the same name !\n\n//Let's create an array of the controlled (selected) tiles on the canvas and store their id into another array\nvar myTilesArray = Array.from(canvas.tiles.controlled);\nvar myTilesIDArray = new Array();\n\nconst wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\nasync function TilesToggle() {\n    \n   \n    for (var i = 0; i < myTilesArray.length; i++) {\n    let tileID = myTilesArray[i].id;\n    myTilesIDArray[i] = tileID;\n    }    \nconst myTilesIDArrayStr = JSON.stringify(myTilesIDArray);\n   \n    await wait (75);\n//everything in between backticks stored into the variable \"command\" will be the code for the \"Tiles Visibility Toggle\" macro !\n    var command = `//This macro will toglle the visibility of a tile from its ID \n    const wait = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n    async function TilesToggle() {\n        \n        var myTilesIDArray = ${myTilesIDArrayStr};\n    \n    \n       for (var i = 0; i < myTilesIDArray.length; i++) {\n        \n        let tileID = myTilesIDArray[i];\n        const tile = canvas.tiles.get(tileID);\n        if(tile) tile.update({ hidden : !tile.data.hidden });\n        await wait (250);\n    \n        }\n        await wait (75);\n    }\n    \n        TilesToggle();`;\n    \n    var macro = await Macro.create({\n        name: \"Tiles Visibility Toggle\",\n        type: \"script\",\n        img: \"icons/svg/eye.svg\",\n        command: `${command}`,\n        \"flags\": {\n            \"furnace\": {\n              \"runAsGM\": true\n            }}\n    }, {displaySheet: false});\n \n\n}\nTilesToggle();","author":"I78VA6a780HpLHg7","img":"icons/svg/book.svg","actorIds":[]}
